[
  {
    "id": 46,
    "title": "Exploring Further. You Don't Know JS Yet",
    "content": "You Don't Know JS Yet: Scope & Closures - 2nd Edition\nAppendix A: Exploring Further\nWe will now explore a number of nuances and edges around many of the topics covered in the main text of this book. This appendix is optional, supporting material.\n\nSome people find diving too deeply into the nuanced corner cases and varying opinions creates nothing but noise and distraction—supposedly, developers are better served by sticking to the commonly-tread paths. My approach has been criticized as being impractical and counterproductive. I understand and appreciate that perspective, even if I don't necessarily share it.\n\n\n\nI believe it's better to be empowered by knowledge of how things work than to just gloss over details with assumptions and lack of curiosity. Ultimately, you will encounter situations where something bubbles up from a piece you hadn't explored. In other words, you won't get to spend all your time riding on the smooth happy path. Wouldn't you rather be prepared for the inevitable bumps of off-roading?\n\n\n\nThese discussions will also be more heavily influenced by my opinions than the main text was, so keep that in mind as you consume and consider what is presented. This appendix is a bit like a collection of mini-blog posts that elaborate on various book topics. It's long and deep in the weeds, so take your time and don't rush through everything here.\n\n\n\nImplied Scopes\nScopes are sometimes created in non-obvious places. In practice, these implied scopes don't often impact your program behavior, but it's still useful to know they're happening. Keep an eye out for the following surprising scopes:\n\nParameter scope\nFunction name scope\nParameter Scope\nThe conversation metaphor in Chapter 2 implies that function parameters are basically the same as locally declared variables in the function scope. But that's not always true.",
    "image": "https://images.unsplash.com/photo-1649733754559-77714250b3be?ixlib=rb-1.2.1&w=2400&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "views": 2,
    "user_id": 1,
    "preview_image": "https://images.unsplash.com/photo-1649733754559-77714250b3be?ixlib=rb-1.2.1&w=640&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "created_at": "2022-08-10T22:59:56.452035+00:00",
    "updated_at": null,
    "first_name": "Ihor",
    "last_name": "Mykhailychenko",
    "avatar": null,
    "email": "user@example.com"
  },
  {
    "id": 45,
    "title": "Illustrating Lexical Scope. You Don't Know JS Yet",
    "content": "You Don't Know JS Yet: Scope & Closures - 2nd Edition\nChapter 2: Illustrating Lexical Scope\n\n\nIn Chapter 1, we explored how scope is determined during code compilation, a model called \"lexical scope.\" The term \"lexical\" refers to the first stage of compilation (lexing/parsing).\n\n\n\nTo properly reason about our programs, it's important to have a solid conceptual foundation of how scope works. If we rely on guesses and intuition, we may accidentally get the right answers some of the time, but many other times we're far off. This isn't a recipe for success.\n\n\n\nLike way back in grade school math class, getting the right answer isn't enough if we don't show the correct steps to get there! We need to build accurate and helpful mental models as foundation moving forward.\n\n\n\nThis chapter will illustrate scope with several metaphors. The goal here is to think about how your program is handled by the JS engine in ways that more closely align with how the JS engine actually works.\n\n\n\nMarbles, and Buckets, and Bubbles... Oh My!\nOne metaphor I've found effective in understanding scope is sorting colored marbles into buckets of their matching color.\n\n\n\nImagine you come across a pile of marbles, and notice that all the marbles are colored red, blue, or green. Let's sort all the marbles, dropping the red ones into a red bucket, green into a green bucket, and blue into a blue bucket. After sorting, when you later need a green marble, you already know the green bucket is where to go to get it.\n\n\n\nIn this metaphor, the marbles are the variables in our program. The buckets are scopes (functions and blocks), which we just conceptually assign individual colors for our discussion purposes. The color of each marble is thus determined by which color scope we find the marble originally created in.",
    "image": "https://images.unsplash.com/photo-1537884944318-390069bb8665?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80",
    "views": 1,
    "user_id": 1,
    "preview_image": "https://images.unsplash.com/photo-1537884944318-390069bb8665?ixlib=rb-1.2.1&w=640&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "created_at": "2022-08-10T22:59:55.949411+00:00",
    "updated_at": null,
    "first_name": "Ihor",
    "last_name": "Mykhailychenko",
    "avatar": null,
    "email": "user@example.com"
  },
  {
    "id": 44,
    "title": "Around the Global Scope. You Don't Know JS Yet",
    "content": "You Don't Know JS Yet: Scope & Closures - 2nd Edition\nChapter 4: Around the Global Scope\n\n\nChapter 3 mentioned the \"global scope\" several times, but you may still be wondering why a program's outermost scope is all that important in modern JS. The vast majority of work is now done inside of functions and modules rather than globally.\n\n\n\nIs it good enough to just assert, \"Avoid using the global scope,\" and be done with it?\n\nThe global scope of a JS program is a rich topic, with much more utility and nuance than you would likely assume. This chapter first explores how the global scope is (still) useful and relevant to writing JS programs today, then looks at differences in where and how to access the global scope in different JS environments.\n\n\n\nFully understanding the global scope is critical in your mastery of using lexical scope to structure your programs.\n\n\n\nWhy Global Scope?\nIt's likely no surprise to readers that most applications are composed of multiple (sometimes many!) individual JS files. So how exactly do all those separate files get stitched together in a single runtime context by the JS engine?\n\n\n\nWith respect to browser-executed applications, there are three main ways.\n\nFirst, if you're directly using ES modules (not transpiling them into some other module-bundle format), these files are loaded individually by the JS environment. Each module then imports references to whichever other modules it needs to access. The separate module files cooperate with each other exclusively through these shared imports, without needing any shared outer scope.\n\n\n\nSecond, if you're using a bundler in your build process, all the files are typically concatenated together before delivery to the browser and JS engine, which then only processes one big file. Even with all the pieces of the application co-located in a single file, some mechanism is necessary for each piece to register a name to be referred to by other pieces, as well as some facility for that access to occur.\n\n\n\nIn some build setups, the entire contents of the file are wrapped in a single enclosing scope, such as a wrapper function, universal module (UMD—see Appendix A), etc. Each piece can register itself for access from other pieces by way of local variables in that shared scope.",
    "image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?ixlib=rb-1.2.1&w=2400&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "views": 3,
    "user_id": 1,
    "preview_image": "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?ixlib=rb-1.2.1&w=640&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "created_at": "2022-08-10T22:59:55.452908+00:00",
    "updated_at": null,
    "first_name": "Ihor",
    "last_name": "Mykhailychenko",
    "avatar": null,
    "email": "user@example.com"
  },
  {
    "id": 43,
    "title": "The (Not So) Secret Lifecycle of Variables. You Don't Know JS Yet",
    "content": "You Don't Know JS Yet: Scope & Closures - 2nd Edition\nChapter 5: The (Not So) Secret Lifecycle of Variables\n\n\nBy now you should have a decent grasp of the nesting of scopes, from the global scope downward—called a program's scope chain.\n\n\n\nBut just knowing which scope a variable comes from is only part of the story. If a variable declaration appears past the first statement of a scope, how will any references to that identifier before the declaration behave? What happens if you try to declare the same variable twice in a scope?\n\n\n\nJS's particular flavor of lexical scope is rich with nuance in how and when variables come into existence and become available to the program.\n\n\n\nWhen Can I Use a Variable?\nAt what point does a variable become available to use within its scope? There may seem to be an obvious answer: after the variable has been declared/created. Right? Not quite.",
    "image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?ixlib=rb-1.2.1&w=2400&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "views": 1,
    "user_id": 1,
    "preview_image": "https://images.unsplash.com/photo-1587620962725-abab7fe55159?ixlib=rb-1.2.1&w=640&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "created_at": "2022-08-10T22:59:54.953927+00:00",
    "updated_at": null,
    "first_name": "Ihor",
    "last_name": "Mykhailychenko",
    "avatar": null,
    "email": "user@example.com"
  },
  {
    "id": 42,
    "title": "Limiting Scope Exposure. You Don't Know JS Yet",
    "content": "You Don't Know JS Yet: Scope & Closures - 2nd Edition\nChapter 6: Limiting Scope Exposure\n\n\nSo far our focus has been explaining the mechanics of how scopes and variables work. With that foundation now firmly in place, our attention raises to a higher level of thinking: decisions and patterns we apply across the whole program.\n\n\n\nTo begin, we're going to look at how and why we should be using different levels of scope (functions and blocks) to organize our program's variables, specifically to reduce scope over-exposure.\n\n\n\nLeast Exposure\nIt makes sense that functions define their own scopes. But why do we need blocks to create scopes as well?\n\n\n\nSoftware engineering articulates a fundamental discipline, typically applied to software security, called \"The Principle of Least Privilege\" (POLP). [^POLP] And a variation of this principle that applies to our current discussion is typically labeled as \"Least Exposure\" (POLE).\n\n\n\nPOLP expresses a defensive posture to software architecture: components of the system should be designed to function with least privilege, least access, least exposure. If each piece is connected with minimum-necessary capabilities, the overall system is stronger from a security standpoint, because a compromise or failure of one piece has a minimized impact on the rest of the system.\n\n\n\nIf POLP focuses on system-level component design, the POLE Exposure variant focuses on a lower level; we'll apply it to how scopes interact with each other.\n\nIn following POLE, what do we want to minimize the exposure of? Simply: the variables registered in each scope.\n\n\n\nThink of it this way: why shouldn't you just place all the variables of your program out in the global scope? That probably immediately feels like a bad idea, but it's worth considering why that is. When variables used by one part of the program are exposed to another part of the program, via scope, there are three main hazards that often arise:\n\nNaming Collisions: if you use a common and useful variable/function name in two different parts of the program, but the identifier comes from one shared scope (like the global scope), then name collision occurs, and it's very likely that bugs will occur as one part uses the variable/function in a way the other part doesn't expect.\nFor example, imagine if all your loops used a single global i index variable, and then it happens that one loop in a function is running during an iteration of a loop from another function, and now the shared i variable gets an unexpected value.\nUnexpected Behavior: if you expose variables/functions whose usage is otherwise private to a piece of the program, it allows other developers to use them in ways you didn't intend, which can violate expected behavior and cause bugs.\nFor example, if your part of the program assumes an array contains all numbers, but someone else's code accesses and modifies the array to include booleans and strings, your code may then misbehave in unexpected ways.\nWorse, exposure of private details invites those with mal-intent to try to work around limitations you have imposed, to do things with your part of the software that shouldn't be allowed.\nUnintended Dependency: if you expose variables/functions unnecessarily, it invites other developers to use and depend on those otherwise private pieces. While that doesn't break your program today, it creates a refactoring hazard in the future, because now you cannot as easily refactor that variable or function without potentially breaking other parts of the software that you don't control.\nFor example, if your code relies on an array of numbers, and you later decide it's better to use some other data structure instead of an array, you now must take on the liability of adjusting other affected parts of the software.\n\n\nPOLE, as applied to variable/function scoping, essentially says, default to exposing the bare minimum necessary, keeping everything else as private as possible. Declare variables in as small and deeply nested of scopes as possible, rather than placing everything in the global (or even outer function) scope.\n\n\n\nIf you design your software accordingly, you have a much greater chance of avoiding (or at least minimizing) these three hazards.",
    "image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?ixlib=rb-1.2.1&w=2400&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "views": 1,
    "user_id": 1,
    "preview_image": "https://images.unsplash.com/photo-1555066931-4365d14bab8c?ixlib=rb-1.2.1&w=640&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "created_at": "2022-08-10T22:59:54.453053+00:00",
    "updated_at": null,
    "first_name": "Ihor",
    "last_name": "Mykhailychenko",
    "avatar": null,
    "email": "user@example.com"
  },
  {
    "id": 41,
    "title": "REST API",
    "content": "REST stands for “Representational State Transfer”.\nClient — Our application is requesting the data.\nDynamic Server/Cloud —The server to which the client will be trying to access the data from.\nWhen a request is sent, the server, in turn, returns the data in either XML or JSON format.\nAPI — This is an Application Programming Interface that helps to connect our application with the Dynamic Server/Cloud.\n\nWhy is the data in XML or JSON format?\nIt’s because the data must follow a particular structure.\n\nOnly the values/state of an object will be sent from the server-side to the client-side in JSON/XML format. [During this, there is transfer of state happening and hence called ‘State Transfer’.]\n\nOperations performed on websites -\n\nWe can perform CRUD Operations and for this we will be using the HTTP methods.",
    "image": "https://images.unsplash.com/photo-1655136420184-0054ed0a0ef0?ixlib=rb-1.2.1&w=2400&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "views": 2,
    "user_id": 1,
    "preview_image": "https://images.unsplash.com/photo-1655136420184-0054ed0a0ef0?ixlib=rb-1.2.1&w=640&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "created_at": "2022-08-10T22:59:53.952972+00:00",
    "updated_at": null,
    "first_name": "Ihor",
    "last_name": "Mykhailychenko",
    "avatar": null,
    "email": "user@example.com"
  },
  {
    "id": 40,
    "title": "Microservices Design Patterns",
    "content": "This is the 3rd post in a series on microservices architecture.\nHigh availability, scalability, resilience to failure, and performance are characteristics of microservices. You can use the microservice architecture pattern in order to architect a microservice application, thereby reducing the risk of failures in microservices.\n\nThe patterns are divided into three layers:\n\nApplication Patterns\nThe application patterns address issues faced by developers such as the decomposition of data, data maintenance, testing, user interface, and some of the observability patterns.\nLet’s go over the basics of these application patterns.\n\nDecomposition patterns\nChoosing how to decompose a monolithic system into services\n\nDecompose by business capability — Services are organized around business capabilities.\nDecompose by subdomain — Services are organized around subdomains of domain-driven design.\nData Patterns\nData consistency — A separate database is used by each service in order to ensure loose coupling. For data consistency across services, the Saga pattern must be used.\nQuerying —The other problem with using a database per service is that some queries need to join data from multiple services. It is impossible to perform distributed queries against a service’s database as its data can only be accessed via its API. Data scattered across multiple services must be retrieved using one of the querying patterns.\nAPI composition — API calls are made to one or more services and results are aggregated.\nCommand Query Responsibility Segregation (CQRS) — The data is maintained in one or more replicas that can be easily queried.\nTesting Patterns\nIndividual microservices are easier to test because they are much smaller than monolithic applications. While testing that the different services work together, it’s important to avoid the use of complex, slow, and unstable end-to-end tests that examine multiple services simultaneously.\n\nConsumer-driven contract test — Ensure that a service meets the expectations of its clients.\nConsumer side contract test — Make sure the client of the service can communicate with it.\nService component test — Isolate the service and test it.\nUI Patterns\nIt is the responsibility of the different teams to display data that correspond to different services and how it is displayed.\n\nServer-side page fragment composition — Each team develops a web application that generates the HTML fragment for the region of the page that their service implements. UI teams develop the page templates by aggregating service-specific HTML fragments on the server-side.\nClient-side UI composition — Each team creates a client-side UI component implementing the region of the screen for their service, such as an AngularJS directive. By composing multiple, service-specific UI components, UI teams implement page skeletons to build screens.\nObservability Patterns\nIn order to operate an application effectively, it is important to understand its runtime behavior and troubleshoot problems such as failed requests.\n\nAudit Logging—Audit logging records the actions of each user. A log of audit activity is typically used to assist in customer support, ensure compliance, and detect suspicious activity.\nApplication metrics—Monitoring and alerting are key components of the production environment. There is a range of metrics, such as the utilization of CPU, memory, and disk, to the latency of service requests and the number of requests executed. Metrics are collected by a metric service, which provides alerting and visualization.\nApplication Infrastructure Patterns\nThey are for infrastructure issues that also affect development, such as communications, observability, reliability, and security patterns.",
    "image": "https://images.unsplash.com/photo-1638633898609-07028cc6d756?ixlib=rb-1.2.1&w=2400&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "views": 6,
    "user_id": 1,
    "preview_image": "https://images.unsplash.com/photo-1638633898609-07028cc6d756?ixlib=rb-1.2.1&w=640&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "created_at": "2022-08-10T22:59:53.453106+00:00",
    "updated_at": null,
    "first_name": "Ihor",
    "last_name": "Mykhailychenko",
    "avatar": null,
    "email": "user@example.com"
  },
  {
    "id": 39,
    "title": "11 Useful Modern JavaScript Tips!",
    "content": "In our day-to-day coding life, we frequently used numbers to string conversion, check keys in the object it exits or not, conditionally manipulate object data, filter falsy value in the array, etc.\n\nHere I come up with some amazing tips which are my personal favorite ❤️ ️and very useful to make my code shorter and clean.\n1. Conditionally add properties💡 in the object\n2. Check if a property exists in an object or not\n3. Object destructing with dynamic key\n4. Loop over an object to access both key and value\n5. Prevent throwing an error 🐞 when accessing any key which does not exist in the object using optional chaining (?.)\nAlert ⚠️: optional chaining used when you are not sure their property exits or not in data. If you are sure that keys must be coming in data and if there does not come, that time is good to throw an error instead prevent them.\n\n6. Check falsy🌵 values in an array\n7. Remove duplicate value in the array\n8. Check value is an array type\n9. String to Number and Number to String conversion using ‘ + ’ operator 🤩\n10. Conditionally assign other values when value is null and undefined using nullish coalescing (??) Operator\nConfuse 😕 with OR (||) Operator ??\n\nOR operator used when you want conditionally assign other value if the value is not truthy (0,’ ’, null, undefined, false, NaN)\n11. Boolean conversion using the !! operator.",
    "image": "https://images.unsplash.com/photo-1622625839082-6fdde07ec172?ixlib=rb-1.2.1&w=2400&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "views": 21,
    "user_id": 1,
    "preview_image": "https://images.unsplash.com/photo-1622625839082-6fdde07ec172?ixlib=rb-1.2.1&w=640&q=80&fm=jpg&crop=entropy&cs=tinysrgb",
    "created_at": "2022-08-10T22:59:52.954762+00:00",
    "updated_at": null,
    "first_name": "Ihor",
    "last_name": "Mykhailychenko",
    "avatar": null,
    "email": "user@example.com"
  },
  {
    "id": 38,
    "title": "5 Javascript Clean Coding Patterns To Enhance your Code",
    "content": "Writing good reusable code can be difficult sometimes. Sometimes we may learn to code in different languages and stick to some limitations or patterns that make sense in that context.\n\nAlthough there is no right or wrong in coding without context, there are some simple ways of writing code that are more generic and can be applied to a lot of contexts, and create more readable, maintainable, and predictable code. Here are some of them:\n\n1. Removing else’s from conditional handling\nEver had a code structure like this, where you have two conditions and then have to handle different codes for each of them:\n\nWell, there’s a different way of dealing with this scenario, that can make things more simple to read.\n\n\nRemoving the elses\nGenerally, you can always work on removing the ‘elses’ from your code. This makes your code easier to read and maintain. Also, if in this scenario, one condition is dependent on the other, the code can be further simplified, by removing the second if.\n\n2. More declarative code with built-in functions\n\nLet’s say you have an array of numbers and you want to sort them. A common implementation would be the following:\n\n\nBubble sorting\nThe implementation works, and sometimes you want to build your own implementations, however, in a simple scenario, you might want to use built-in functions for some reasons:\n\nThey make the code smaller, and smaller code tends to be more maintainable (not always true though);\nThey already use implementations that are more worked on, so can be faster, more secure, and known by other developers;\nThis way, using the array method sort from javascript ES6 the code can be greatly simplified and also improved the speed for bigger arrays.\n\n\nJavascript sort array method\nThis is also valid for other scenarios, and not only arrays. It’s a good practice to use built-in functions when the scenarios are more generic, and you should avoid them when they don’t fill your application requirements, such as speed, security, and portability. Here are some more array methods.\n\n3. Separate your code into logical blocks\nThis one is valid not only for javascript but for most languages. Let’s say you have the following business scenario. An input array of fruits that need to be parsed then determines if the fruit is citric or not and then does some processing.\n\n\nSome fruit business logic\nNow, what happens if the separator inside the input changes? Or the types of each fruit? The output? In this scenario, it’s easy to change things, but many times the code is very complex, and each step has complex logic. One way of handling this is by decoupling and identifying the key steps of a process.\n\n\nApple is citric?\nHere we identified that the parsing, the handling of the citric fruit, and the output are the steps of the process, and we have decoupled each part, so now if the input changes or some part change we have a more robust and easy to change code. Business rules are not as easy to determine, but a good step is to speak with the person that is the reference for the product and work around these critical parts, especially in applications that are subject to constant changes.\n\n4. Switch case with dictionaries\nLet’s say you have a filter logic inside your application. A common way of handling this is by using the switch case statement.\n\n\nSwitch case for filters\nThere’s nothing wrong with this approach, however, there’s a readable that also helps when order matters for the response of each statement. Using dictionaries. In javascript the default object is already a dictionary, that is, an unordered array where the elements can be accessed using a key, normally a string or a numeric value. This also means that dictionaries shine in problems where order doesn’t matter, but only access.\n\n\nDictionary conditionals\nAlso, the return and the index are not limited by simple strings. Numbers and functions can be applied too, making this pattern usable in many different situations.\n\n5. Use destructuring/spread for simple object reassignment\nIf you’re managing state, you may eventually find yourself in a situation where you have to manipulate and change or reassign objects. A simple way of avoiding mutation is simply looping over an object and reassigning it.\n\n\nHandling state/object changes\nWith ES6 we have a more simple way of doing this, using the Object.assign method or even simpler spread syntax.\n\n\nSpread operator new assign\nThis will create a new Object, and avoid mutation, along with being shorter than the other options.\n",
    "image": "https://images.unsplash.com/photo-1621609764095-b32bbe35cf3a?ixlib=rb-1.2.1&ixid=MnwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1528&q=80",
    "views": 1,
    "user_id": 1,
    "preview_image": "https://images.unsplash.com/photo-1621609764095-b32bbe35cf3a?ixlib=rb-1.2.1&ixid=MnwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1528&q=80",
    "created_at": "2022-08-10T22:59:52.449451+00:00",
    "updated_at": null,
    "first_name": "Ihor",
    "last_name": "Mykhailychenko",
    "avatar": null,
    "email": "user@example.com"
  },
  {
    "id": 37,
    "title": "Stop using console.log",
    "content": "Stop using console.log for everything 🙄. I have seen and continue to see many developers regularly use the console object’s log method in a way that I think is incorrect.\n\nUsing console.log for debugging\nMany developers still use the log method to debug their application. For example, to make sure that the code goes somewhere or that a variable has the right value at a given time.\n\nThere are several downsides to this.\n\nYou have no view on the whole life cycle of your application, only on the value of a variable at a given time or the assurance or not that your code is following its logical flow.\n\nIt often happens that console.log are forgotten in several places in the code, which besides a hypothetical loss of performance (tiny, but whose size varies according to the data called through the log method), is not very clean.\n\nThe solution is to use the debugging tools provided by your browser. It may take a little bit of learning, but the rewards outweigh the effort 🚀.\n\nThis way you will have full control over the life cycle of your code and avoid forgetting your console.log in your code.\n\nSee: Debug JavaScript with the Chrome DevTools or Use the JavaScript debugger by Mozilla Firefox.\n\nUsing only the method log\nAgain, many developers use console.log to display any kind of message: information, error, warning, etc.\n\nThe console object that gives access to the debugging console of the browser has many methods with very specific uses.\n\nHere is an exhaustive list of the most frequently used methods:\n\nconsole.error → Shows an error message\nconsole.warn → Shows a warning message\nconsole.info → Shows an informative message (special rendering on Firefox, but technically identical to log method)\nconsole.log → Shows a global message\nconsole.debug → Shows a message to the console with the log level debug\nconsole.table → Shows data of an array/object as a table\nconsole.time (with console.timeEnd) → Allows you to set a timer to see how long a task needs to be completed.\n\nThe specific case of the debug method\nPersonally, I consider the use of the debug method in three different situations.\n\nIn the first case, we want to display a piece of information quickly on the screen (e.g. the value of a variable). Even if it is not optimal, the logging level of this method makes the message remain “hidden” by default to the user (except if the verbose mode of his console is activated).\n\nIn the second case, we want to use the method as an anchor to our source file (we can use the debugger statement too if you want but personally I don’t like it).\n\n\nSecond case example\nIn the third case, we want to use an on-demand debugging log system in production. For example, a function registered directly in the window object can trigger a log display in the user’s console. This use case can be useful when we don’t have pre-production environments at our disposal and when a bug raised by a customer is difficult to reproduce in a development environment.\n\nRemove console.debug from production\nExcept if you are in the third case we just saw, I advise you to use something like a git pre-commit hook or plugin to check methods or keywords you don’t want to appear before the production release.\n\nYou can use UglifyJS to filter on these keywords.\n\nThank you for reading 🙏.\n\nFeel free to share and/or follow me. It would help me a lot 😁",
    "image": "https://images.unsplash.com/photo-1660039031080-7779c1760a0c?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80",
    "views": 8,
    "user_id": 1,
    "preview_image": "https://images.unsplash.com/photo-1660039031080-7779c1760a0c?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80",
    "created_at": "2022-08-10T22:59:52.003008+00:00",
    "updated_at": null,
    "first_name": "Ihor",
    "last_name": "Mykhailychenko",
    "avatar": null,
    "email": "user@example.com"
  }
]
